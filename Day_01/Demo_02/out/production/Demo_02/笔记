
2022.9.30
1.
  四个访问修饰符：
   public
   protected
   默认
   private

2.封装 继承 多态

    封装：抽象的数据和对数据的操作封装在一起，数据保护在内部，程序的其他的部分只有通过被授权的操作，才能对数据进行操作

    1.隐藏实现的细节  方法--数据库  我们只是调入参数即可
    实现：（1）将属性私有化  外部不能修改属性
          （2）提供一个公共的set方法 用于对属性判断并且赋值
          （3）提供一个公共的get方法 用于获取属性的值

        2.可以对数据进行验证

    继承：extends

     使用一套业务逻辑
     两个类的属性和方法很多地方相同
     解决代码的复用

     1.子类继承了所有的属性和方法，但是私有属性和方法不能在子类里面直接访问，要通过方法进行访问

     Super的使用 用来调用父类的构造器
     super 是默认的 只要有构造器 一定有super
     构造器都有隐藏的一个SUper
     先执行父类的构造器 在执行子类的构造器 继承关系
     super 和 this都只能在第一行使用



  继承的本质：
        当子类对象创建好后，建立查找的关系

   super 关键字
   就近原则
     1.通过super访问父类的属性 方法 但是不能访问父类的私有方法
     2.可以访问父类的构造器，在本类的构造器访问父类的构造器

      子类调用父类的方法
      1.cal()
      2.this.cal()
      3.super.cal() //直接查找父类的cal方法 不会在访问本类的方法

      this 和super 的比较
      本类    父类

   方法重写/覆盖 override
   1.参数名和方法名称一样
   2.层级关系

    重载/重写 overload/override
    本类  父类
    必须一样
1.重写(Override)
从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。
子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，
不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。



多态：
   1.方法的多态
   重载和重写就是多态的体系
   2.对象的多态
    (1) 编译类型和运行类型不一样;
    (2) 编译类型在定义对象时，就确定了，不能改变
    （3）运行类型可以变化
    （4）编译类型定义时=号的左边 运行类型看=号的右边

    前提：建立在封装和继承之上的
    父类的应用指向子类的对象
   --- 向上转型
    1.可以调用父类的所有成员 （遵守访问权限）
    2.不能调用子类的特有的成员
    因为在编译阶段，能调用那些成员是编译类型决定
    最终运行效果看子类的具体实现
    运行程序看运行类型
    --向下转型

    --属性重写问题  ==属性的值 看编译类型  方法看运行类型
    --instanceof 类型比较操作符  判断对象的运行类型是否为某某类型或者某某类型的子类型

    --动态绑定机制 --调用该方法时跟运行类型进行动态绑定 属性没有动态绑定机制
     还是继承机制

     --动态数组的应用
     1.多态数组
     数组的定义类型是父类类型，里面保存的实际元素类型为子类类型
     2.多态参数
     方法的形参类型是父类类型 实参是子类类型








